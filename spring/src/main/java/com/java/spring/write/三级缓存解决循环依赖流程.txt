循环依赖关机
AService --> BService、CService
BService --> AService
CService --> AService

1----------
AService生命周期
1. class -> BeanDefinitions
2.aservcie = new AService();// 原始对象-->三级缓存(aService:lambda(原始对象))
3.属性填充->填充bService属性-->从单例池找bSercive对应的那个bean对象-->不能找到-->三级缓存找-->创建BService
4.初始化
5.BeanPostProcessor----判断是不是提前进行了AOP-->AbstractAutoProxyCreater
在这之前得到的对象都是原始对象
6.bean添加到单例池

2----------
BService生命周期
1. class -> BeanDefinitions
2.aservcie = new BService();// 原始对象-->三级缓存(bService:lambda(原始对象))
3.属性填充->填充aService属性-->从单例池找aSercive对应的那个bean对象-->不能找到-->二级缓存map->三级缓存找-->lambda(原始对象)->执行lambda-->aop-->代理对象-->二级缓存map-->删除lambda
4.初始化
5.BeanPostProcessor----判断是不是提前进行了AOP
6.bean添加到单例池

2----------
CService生命周期
1. class -> BeanDefinitions
2.aservcie = new CService();// 原始对象-->三级缓存(bService:lambda(原始对象))
3.属性填充->填充aService属性-->从单例池找aSercive对应的那个bean对象-->不能找到-->二级缓存map->三级缓存找-->lambda(原始对象)->执行lambda-->aop-->代理对象-->二级缓存map-->删除lambda
4.初始化
5.BeanPostProcessor----判断是不是提前进行了AOP

6.bean添加到单例池


三级缓存
第一级缓存:单例池 concurrentHashMap singletonObjects
第二级缓存:map earlySingletonObjects -->存放代理对象
第三级缓存:map singletonFactories --> Map(beanName,lambda(原始对象))


存放提前aop的对象，不属于三级缓存中的map concurrentHashMap earlyProxyReferences map(beanName,原始对象),用于判断是否提前进行了AOP
存放创建中的Set singletonCurrentlyInCreation


代理对象怎么放入单例池？后置处理器处理过程中，从二级缓存中拿到代理对象，如果beanName和传递过来的beanName一样的话就把代理对象放到单例池中
怎么判断是不是提前进行了AOP？ --AbstractAutoProxyCreater判断

如果不存在AOP的情况，二级缓存就能解决循环依赖，存在AOP的情况下,需要处理代理对象情况,此时引入第二级缓存保存生成的代理对象，第三级缓存保存的bean名称和lambda表达式
，严格的讲，解决循环依赖并不只是需要三级缓存，而是需要5个map也就是5级缓存

